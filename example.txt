from fastapi import FastAPI, HTTPException, UploadFile, File, Query
from fastapi.responses import FileResponse
from pydantic import BaseModel
from typing import Any, Dict, Optional, List, Tuple
from pathlib import Path
from dotenv import load_dotenv
import os, json, time, re
from io import BytesIO
from openpyxl import load_workbook
from openpyxl.utils import column_index_from_string
from service.ingest import read_excel_multi

load_dotenv()

app = FastAPI(title="Link Automation API", version="0.4.0")
B_TEMPLATE_PATH = "./templates/file_f.xlsx"

class UploadExtractResponse(BaseModel):
    sheets_found: List[str]
    columns: Dict[str, List[str]]
    data_preview: Dict[str, List[Dict[str, Any]]]

def _norm(name: str) -> str:
    return re.sub(r'[^a-z0-9]', '', str(name).lower())

def _find_sheet_with_columns(sheets: Dict[str, Any], required: List[str]) -> Tuple[Optional[str], Optional[Any]]:
    for sheet_name, df in sheets.items():
        norm_map = {_norm(c): c for c in df.columns}
        if all(_norm(col) in norm_map for col in required):
            return sheet_name, df
    return None, None

@app.get("/healthz")
def healthz():
    return {"status": "ok"}

@app.post("/upload-extract", response_model=UploadExtractResponse)
async def upload_extract(file: UploadFile = File(...), limit: int = Query(50, ge=1, le=500)):
    allowed = {"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/octet-stream"}
    if file.content_type not in allowed:
        raise HTTPException(415, f"Unsupported content type: {file.content_type}. Please upload a .xlsx file.")
    raw = await file.read()
    max_bytes = 25 * 1024 * 1024
    if len(raw) > max_bytes:
        raise HTTPException(413, f"File too large ({len(raw)} bytes). Max allowed is {max_bytes} bytes.")
    sheets = read_excel_multi(raw)
    data_preview = {}
    columns = {}
    for name, df in sheets.items():
        columns[name] = [str(c) for c in df.columns]
        preview = df.head(limit).fillna("").astype(str).to_dict(orient="records")
        data_preview[name] = preview
    return {"sheets_found": list(sheets.keys()), "columns": columns, "data_preview": data_preview}

@app.post("/upload-map-template")
async def upload_map_template(
    file: UploadFile = File(...),
    mode: str = Query("auto", regex="^(auto|headers|coords)$"),
    sheet_name: Optional[str] = Query(None, description="Optional source sheet (headers/auto)."),
    start_index: int = Query(7, ge=0, description="Zero-based row index for headers-mode."),
    src_sheet_name: Optional[str] = Query(None, description="Source sheet (coords mode)."),
    src_hostname_col: str = Query("B", description="Source column for HostName in coords mode."),
    src_vendor_col: str = Query("E", description="Source column for Vendor in coords mode."),
    src_start_row: int = Query(8, ge=1, description="Source start row in coords mode."),
):
    """
    Upload a source .xlsx and generate a new .xlsx from the template:
      - headers mode: uses 'HostName'/'Vendor' columns (skips `start_index` rows)
      - coords mode: reads from explicit coordinates (e.g., B8/E8 downward)
      - auto (default): try headers, else fallback to coords
    Writes to template SHEET 'B': Hostname -> A9.., Vendor -> B9..
    """
    allowed = {
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "application/octet-stream"
    }
    if file.content_type not in allowed:
        raise HTTPException(415, f"Unsupported content type: {file.content_type}. Please upload a .xlsx file.")

    raw = await file.read()
    max_bytes = 25 * 1024 * 1024
    if len(raw) > max_bytes:
        raise HTTPException(413, f"File too large ({len(raw)} bytes). Max allowed is {max_bytes} bytes.")

    # --- Load template safely (avoid Excel 'content problem' alert)
    template_path = B_TEMPLATE_PATH
    if not template_path or not Path(template_path).exists():
        raise HTTPException(500, f"Template path not found. Set B_TEMPLATE_PATH env var (current: {template_path!r}).")

    # If your template is .xlsm/.xltm (macros), keep_vba=True; otherwise False
    ext = Path(template_path).suffix.lower()
    keep_vba = ext in (".xlsm", ".xltm")

    # keep_links=False strips any external references that often trigger Excel repair prompts
    wb_tmpl = load_workbook(template_path, data_only=False, keep_vba=keep_vba, keep_links=False, read_only=False)
    wb_tmpl.template = False  # ensure we save a normal .xlsx

    if "Deployment Report" not in wb_tmpl.sheetnames:
        raise HTTPException(500, "Template sheet 'B' not found. Please ensure your template has a sheet named 'B'.")
    ws_tmpl = wb_tmpl["Deployment Report"]  # target sheet

    # Helper: write into A9/B9 downward and finalize workbook cleanly
    def write_to_template(rows_iter):
        excel_row = 9  # start at row 9
        count = 0
        for hostname_val, vendor_val in rows_iter:
            ws_tmpl.cell(row=excel_row, column=1, value=hostname_val)  # A
            ws_tmpl.cell(row=excel_row, column=2, value=vendor_val)    # B
            excel_row += 1
            count += 1

        # Clean up broken defined names that can prompt Excel repairs
        try:
            dn_list = list(getattr(wb_tmpl.defined_names, "definedName", []))
            for dn in dn_list:
                if "#REF!" in str(getattr(dn, "attr_text", "")):
                    wb_tmpl.defined_names.delete(dn.name)
        except Exception:
            pass

        # Recalculate sheet dimensions to avoid invalid dimension metadata
        for ws in wb_tmpl.worksheets:
            try:
                ws.calculate_dimension(force=True)
            except Exception:
                pass

        out_dir = Path("./out"); out_dir.mkdir(parents=True, exist_ok=True)
        out_path = out_dir / f"mapped_{int(time.time())}.xlsx"
        wb_tmpl.save(out_path)
        return out_path, count

    # ------- headers mode (or auto attempt)
    if mode in ("headers", "auto"):
        sheets = read_excel_multi(raw)
        required_cols = ["HostName", "Vendor"]

        def _norm(s: str) -> str:
            import re
            return re.sub(r"[^a-z0-9]", "", str(s).lower())

        def _find_sheet_with_columns(sheets, required):
            for sname, df in sheets.items():
                norm_map = {_norm(c): c for c in df.columns}
                if all(_norm(col) in norm_map for col in required):
                    return sname, df
            return None, None

        if sheet_name and sheet_name in sheets:
            df = sheets[sheet_name]
            norm_map = {_norm(c): c for c in df.columns}
            if all(_norm(c) in norm_map for c in required_cols):
                col_hostname = norm_map[_norm("HostName")]
                col_vendor   = norm_map[_norm("Vendor")]
                df_use = df.iloc[start_index:].copy()
                def it_rows():
                    for _, r in df_use.iterrows():
                        yield r.get(col_hostname), r.get(col_vendor)
                out_path, _ = write_to_template(it_rows())
                return FileResponse(str(out_path),
                                    media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                                    filename=out_path.name)

        sel_name, df = _find_sheet_with_columns(sheets, required_cols)
        if sel_name is not None:
            norm_map = {_norm(c): c for c in df.columns}
            col_hostname = norm_map[_norm("HostName")]
            col_vendor   = norm_map[_norm("Vendor")]
            df_use = df.iloc[start_index:].copy()
            def it_rows():
                for _, r in df_use.iterrows():
                    yield r.get(col_hostname), r.get(col_vendor)
            out_path, _ = write_to_template(it_rows())
            return FileResponse(str(out_path),
                                media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                                filename=out_path.name)

        if mode == "headers":
            raise HTTPException(422, "Required columns ['HostName','Vendor'] not found in the selected workbook/sheet.")

    # ------- coords mode (or auto fallback)
    from io import BytesIO
    from openpyxl.utils import column_index_from_string

    wb_src = load_workbook(BytesIO(raw), data_only=True, keep_links=False, read_only=True)
    if src_sheet_name and src_sheet_name in wb_src.sheetnames:
        ws_src = wb_src[src_sheet_name]
    elif sheet_name and sheet_name in wb_src.sheetnames:
        ws_src = wb_src[sheet_name]
    else:
        ws_src = wb_src[wb_src.sheetnames[0]]  # first sheet

    try:
        col_h = column_index_from_string(str(src_hostname_col))
        col_v = column_index_from_string(str(src_vendor_col))
    except Exception:
        raise HTTPException(422, f"Invalid column letters: HostName='{src_hostname_col}', Vendor='{src_vendor_col}'")

    start_row = int(src_start_row)
    max_row = ws_src.max_row or (start_row + 1000)

    def it_rows_coords():
        blank_tail = 0
        for r in range(start_row, max_row + 1):
            h = ws_src.cell(row=r, column=col_h).value
            v = ws_src.cell(row=r, column=col_v).value
            if (h is None or str(h).strip() == "") and (v is None or str(v).strip() == ""):
                blank_tail += 1
                if blank_tail >= 50:
                    break
            else:
                blank_tail = 0
            yield h, v

    out_path, cnt = write_to_template(it_rows_coords())
    if cnt == 0:
        raise HTTPException(422, "No data found at the provided coordinates. Check src_* params or source file.")
    return FileResponse(str(out_path),
                        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                        filename=out_path.name)
